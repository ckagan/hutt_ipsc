---
title: "Hutterite iPSC Panel QC"
author: "Courtney Kagan"
output:
  html_document:
    toc: true
    toc_depth: 2
---

Last updated: `r Sys.Date()`

Code version: `r# system("git log -1 --format='%H'", intern = TRUE)`

This is the workflow used for QC and initial expression data analysis on the 73 Hutterite iPSC samples. 

#Hutterite iPSC Expression QC
47,307 probes on the Illumina Ht12v4 expression array for 73 Hutterite iPSC lines. We remove all probes with a SNP (and additional criteria) and have 22,034 remaing for anlysis. Please see ___ for details on probe exclusion.
```{r echo=FALSE, include=FALSE}
library(lumi)
setwd("C:/Users/Courtney/Dropbox/LCL-iPSC/GEMMA eQTLs/Hutt iPSCs")

##Create object with name of data file:
data = c('YGilad-CK-Mar6-15-ProbeLevelData-NotNormalized-NoBGSubtracted-FinalReport.txt')

##Extract raw data from lumi file and preparing for removing bad probes:
data.lumi = lumiR.batch(data, lib.mapping=NULL, convertNuID=F,annotationColumn=c('ACCESSION', 'SYMBOL', 'PROBE_SEQUENCE', 'PROBE_START', 'CHROMOSOME', 'PROBE_CHR_ORIENTATION', 'PROBE_COORDINATES', 'DEFINITION','PROBE_ID'))

###Remove Probes (mapped to hg19, removed those with SNPs MAF>.05, no exon spanning probes and converted to Ensembl gene IDS)
##Probe list generated by John Blischak December 2014 https://github.com/jdblischak/filter_probes
all.probes = data.lumi@featureData[[5]]
goodprobes= read.table('ht12_probes_snps_ceu_hg19_af_0.05_map_37.txt', header=T, sep='\t')
#22,034 probes
probes = goodprobes$probeID
## Convert from factor to character
probes = as.character(goodprobes$probeID)
cleanprobes = which(all.probes %in% probes)
data.lumi.clean = data.lumi[cleanprobes,]
#22,032 probes
head(data.lumi@featureData[[5]])
head(data.lumi.clean@featureData[[5]])

#Add in sample names
samplenames = read.table('Covars.txt', header=T, sep ='\t')
#Re-order samplenames based on array location
samplenames = samplenames[order(samplenames$Order),]
sampleNames(data.lumi.clean) = samplenames$Sample


###Remove heart samples####
hearts = c(56:60,67:72)
data.lumi.clean = data.lumi.clean[,-hearts]
samplenames = samplenames[-hearts,]
```
##Normalization
First we quantile normalize the data using the lumi package in R.
```{r}
###### NORMALIZATION: log2 stabilized and quantile normalization ###################
data.norm.all <- lumiExpresso(data.lumi.clean, bg.correct=TRUE, bgcorrect.param=list(method='forcePositive'), variance.stabilize=TRUE, varianceStabilize.param = list(method="log2"), normalize=TRUE, normalize.param=list(method="quantile"), QC.evaluation=TRUE, QC.param=list(), verbose=TRUE)

```
##QC
Start with looking at things Pre- and Post-Normalization.
```{r echo=FALSE, fig.width=7, fig.height=6}
############# QC #####################

##Look at plots of array data (boxplot, density, etc) :
boxplot(data.lumi.clean, main= "Pre-normalization")
boxplot(data.norm.all, main = "Post-Normalization")

plot(data.lumi.clean, what='density', main= "Density plot of intensity Pre-normalization")
plot(data.norm.all, what='density', main = "Density plot of intensity Post-Normalization")

##Check that replicates are most related
plot(data.norm.all, what='sampleRelation', main = "Post-Normalization")
```
We see that the normalized data looks as expected.

##Probe Detection
Next we filter out probes based on detection. We count the number of times a probe has a detection p-value <.05 in all 73 indivduals to see if we should include it.
```{r include=FALSE}
######### Probe Detection #############
#Look for detection
detection = data.norm.all@assayData$detection
#colnames(detection) = sampleorder
colnames(detection) = samplenames$Sample
#Count the number of probes that have a detection p-value<.05
detected = rowSums(detection <0.05)
```

```{r echo=FALSE, fig.width=7, fig.height=6}
hist(detected, breaks = 60, main="Histogram of Detected Probes by Individual", xlab = "Number of Individuals", ylab = "Frequency of Detected Probes")
```

```{r include=FALSE}
#Here is where I select the number of indiv that need to have the probe expressed
detect.gene<- which(detected > 7)

norm_quant.all <- data.norm.all@assayData$exprs
###Find the column that is lumi_ID in feature data usually this column
head(data.norm.all@featureData[[5]])
##[1] "ILMN_1343291" "ILMN_1343295" "ILMN_1651199" "ILMN_1651209" "ILMN_1651210" "ILMN_1651221"
###Convert expr_quant rownames to
rownames(norm_quant.all)=data.norm.all@featureData[[5]]
#With this threshold 14,306 probes out of 47,307 are expressed
expr_quant.all <- norm_quant.all[detect.gene,]
```

At 7 individuals there is an inflection point (also around 10% of the samples) and for that reason I chose to exclude probes that had a detection p-value <.05 in 7 inviduals or less. This leaves us with 14,306 probes.

```{r echo=FALSE, include=FALSE}
###### Load in Covariates ###############
#Converted some factors so they are categorical 
colnames(expr_quant.all) = samplenames$Sample

batch = samplenames$Batch
type = samplenames$Type
sex =  samplenames$Sex
age = samplenames$Age
pluri =  samplenames$Pluri
novel = samplenames$Novelty
matbot = samplenames$Matrigel.Bottle
pas = samplenames$Passage

#Converted categorical covariates to a factor so they are levels 
batch.f = as.factor(batch)
pas.f = as.factor(pas)
matbot.f = as.factor(matbot)
sex.f = as.factor(sex)

#Converted numerical covariates to a numeric so they are continuous
pluri.num =as.numeric(pluri)
novel.num = as.numeric(novel)
age.num = as.numeric(age)
```
##Conversion to Gene
Next we converted the probes to genes. And found that we have 10,950 unique genes represented.
```{r}
######## Converting probes to gene #################
## Finding the unique gene names matching probes to gene names using the good probe list
gene_names=c()
for(i in 1:dim(expr_quant.all)[1]){
  gene_names=c(gene_names,as.vector(goodprobes[as.vector(goodprobes$probeID)==row.names(expr_quant.all)[i],7]))
}

symbolsUniq = unique(gene_names)
length(symbolsUniq)
# 11,237 have gene names


## This loop will give the most 3' value for multiple probes within the same gene. In the end you get a simple file with all genes that are expressed with the corresponding mean intensity expression levels across its different probes.
expr_gene = matrix(NA, ncol=73, nrow=length(unique(gene_names)))
i=0
for(gene in unique(gene_names)){
  i = i+1
  
  currRows = which(gene_names == gene)
  if(length(currRows)>1){
    if(goodprobes[currRows[1],6]=="+"){
      keepRow = currRows[which.max(goodprobes[currRows,2])]
    }
    else{
      keepRow = currRows[which.min(goodprobes[currRows,2])]
    }
  }
  else{
    keepRow=currRows[1]
  }
  expr_gene[i,] = expr_quant.all[keepRow,]
  
} 
dim(expr_gene)
#11237 73
rownames(expr_gene) = unique(gene_names)
colnames(expr_gene) = colnames(expr_quant.all)
```

```{r include=FALSE}
##If gene names are not Ensembl then you will need to remove NAs###
#colnames(expr_gene) =samplenames$Name
##One gene is labeled "NA" and therefore also has no data attached
#which(is.na(row.names(expr_gene)))
#Row 4110 is NA
#expr_gene_new = na.omit(expr_gene)
#dim(expr_gene_new)
# 10949    73
#expr_gene = expr_gene_new
#write.table(expr_gene, 'OriginGeneExpression_Normalized.txt', sep='\t', row.names=T, quote=F)
```

```{r include=FALSE}
######### Start from Data ###########

#expr_gene = read.table('OriginGeneExpression_Normalized.txt', header=T, as.is=T, sep='\t', row.names=1)
#samplenames = read.table('Covars.txt', header=T, sep ='\t')
#Re-order samplenames based on array location
#samplenames = samplenames[order(samplenames$Order),]

#hearts = c(56:60,67:72)
#samplenames = samplenames[-hearts,]
#colnames(expr_gene) = samplenames$Sample
#goodprobes= read.table('ht12_probes_snps_ceu_hg19_af_0.05_map_37.txt', header=T, sep='\t')

## Create expression table for GEMMA ####
#expr_gene_new = t(expr_gene)
## Re-order by individual in excel
#write.table(expr_gene_new, 'OriginGeneExpression_Normalized_GEMMA.txt', sep='\t', row.names=T, quote=F)
```

############## Data Analysis ####################

##### Generate chr and gene list for later filtering ##########
#Generate the chr file to get autosomes only

#Create probe info list with chr, probe, and gene column
probeinfolist = cbind(goodprobes$chr, as.character(goodprobes[,4]),as.character(goodprobes[,8]))
#Create lists of actual probes and genes from the data
#probelist = rownames(expr_quant.all)
genelist = rownames(expr_gene)
#probelist = as.matrix(probelist)
genelist = as.matrix(genelist)
#colnames(probelist) = c("ILMN")
colnames(genelist) = c("GeneID")
colnames(probeinfolist) = c("Chr", "Probe", "Gene")
#Merge actual list with reference information from good probe document
#chrlist.probe = merge(probelist, probeinfolist, by.x = "ILMN", by.y = "Probe", all.x = T, all.y = F, sort=F)
chrlist.gene = merge(genelist, probeinfolist, by.x = "GeneID", by.y = "Gene", all.x = T, all.y = F, sort=F)
clean.chrlist.gene = chrlist.gene[!duplicated(chrlist.gene$GeneID), ]
#To check for NAs
which(is.na(clean.chrlist.gene))
#Generate final lists
#chrfinal.p = as.matrix(chrlist.probe[,2])
chrfinal.g = as.matrix(clean.chrlist.gene[,2])
table(chrfinal.g)
#Only 1-24 represented
#   1   10   11   12   13   14   15   16   17   18   19    2   20   21   22   23   24    3    4    5    6    7    8    9 
# 1141  162  782  702  316  125  275  615  412  489  549  405  489  379  415  422   14  647  576  187  355  354  476  662 
xchr = clean.chrlist.gene[which(clean.chrlist.gene$Chr ==23 ),]
#422 X chr genes
ychr = clean.chrlist.gene[which(clean.chrlist.gene$Chr ==24 ),]
#14 Y chr genes
hist(as.numeric(chrfinal.g), breaks = 24, xlim = c(1,24))
sexgenes = c(which(clean.chrlist.gene$Chr == 23 ), which(clean.chrlist.gene$Chr ==24 ))
expr_gene_nosex = expr_gene[-sexgenes,]
# 10,513 genes on autosomes only

#### Look at Variance ############
#variance by gene
variance.iPSC = apply(expr_gene,1,var)
#variance.Heart = apply(expr_gene[,grep ("HT14", colnames(expr_gene))],1,var)

#mean(variance.Heart)
# 0.2380351
mean(variance.iPSC)
# 0.02569707

#variance.all = cbind(variance.iPSC, variance.Heart)
#boxplot(variance.all)
write.table(variance.iPSC, 'Variance.txt', quote=F, sep='\t')
#var.test(variance.Heart, variance.iPSC)

library(ggplot2)
var_all <- data.frame(var=c(variance.iPSC), type = rep("iPSC"), times=c(length(variance.iPSC)))
ggplot(var_all, aes(x=var, fill=type)) + geom_density(alpha=0.09) +xlim(-.01,.25)+xlab("Variance") + ggtitle("Gene Expression: Total variance") + theme(legend.position=c(.75,.75)) +theme(text = element_text(size=23))

##### Read in data for dendograms and PCA #########

# Make labels and colors for the data
labs = samplenames$Sample

library(ClassDiscovery)
#### Create dendograms with all genes ##########
pdf(file = "Dendrograms.pdf")
euc = hclust(dist(t(expr_gene)))
plotColoredClusters(euc, labs, cols = 'black', cex = .6,lwd =3, lty = 1,main = "Euclidean Distance", line = -1, xlab="", sub="", col.main = "#45ADA8")

#Make dendograms using pearson
pears = hclust(as.dist(1-cor(as.matrix(expr_gene))))
plotColoredClusters(pears, labs, cols = 'black', cex = .6,lwd = 3, lty = 1,main = "Pearson Correlation", line = -1, xlab="", sub="", col.main = "#45ADA8")
dev.off()

###### Create dendograms of autosomes only and 1k most variable - only iPSCs ##########
#Create expr data set of 1k most variable genes 
var.ipsc = as.matrix(variance.iPSC)
var_1k = as.matrix(var.ipsc[order(var.ipsc, decreasing = T),])
var1k = as.matrix(var_1k[1:1000,])
cols = samplenames$Batch

expr_gene = var1k

pdf(file = "Dendrograms_nosex_1k.pdf")
euc = hclust(dist(t(expr_gene[,grep ("LCL|Fib" , colnames(expr_gene), invert = T)])))
plotColoredClusters(euc, labs, cols, cex = 1,lwd = 3, lty = 1,main = "Euclidean Distance", line = -1, xlab="", sub="")
#Make dendograms using pearson
pears = hclust(as.dist(1-cor(as.matrix(expr_gene))))
plotColoredClusters(pears, labs, cols, cex = 1,lwd = 3, lty = 1,main = "Pearson Correlation", line = -1, xlab="", sub="")
dev.off()

####### Create dendograms of autosomes only ##################
pdf(file = "Dendrograms_nosex.pdf")
euc = hclust(dist(t(expr_gene_nosex)))
plotColoredClusters(euc, labs, cols, cex = 1,lwd = 3, lty = 1,main = "Euclidean Distance", line = -1, xlab="", sub="", col.main = "#45ADA8")
#Make dendograms using pearson
pears = hclust(as.dist(1-cor(as.matrix(expr_gene_nosex))))
plotColoredClusters(pears, labs, cols, cex = 1,lwd = 3, lty = 1,main = "Pearson Correlation", line = -1, xlab="", sub="", col.main = "#45ADA8")
dev.off()

######### Make heatmap of the data ##################
pdf(file="Heatmaps.pdf")
library(gplots)
heatmap.2(cor(as.matrix(expr_gene), use = "complete"), margins=c(7,8),trace="none",main="Gene Expression Correlation", key=T, keysize=1.5,density.info="none",cexCol=0.9)
heatmap.2(cor(as.matrix(expr_gene_nosex), use = "complete"), margins=c(7,8),trace="none",main="Gene Expression Correlation \niPSCs Without X", key=T, keysize=1.5,density.info="none",cexCol=0.9)
dev.off()

##################### PCA #################
##All the data
x.pca = prcomp(na.omit(t(expr_gene)), center = T,scale=T)
x.pca.sum = summary(x.pca)
pdf(file = "PCA.pdf")
plot(x.pca$x[,1], x.pca$x[,2], xlab = paste('PC1 (',x.pca.sum$importance[2,1], ')', sep = ''),ylab = paste('PC2 (',

], ')', sep = ''), main = "PC1/2 all data", pch = 20, col = samplenames$Batch)
text(x.pca$x[,1], x.pca$x[,2], samplenames$Batch)
plot(x.pca$x[,1], x.pca$x[,3], xlab = paste('PC1 (',x.pca.sum$importance[2,1], ')', sep = ''),ylab = paste('PC3 (',x.pca.sum$importance[2,3], ')', sep = ''), main = "PC1/3 all data", col =samplenames$Batch, pch = 20)
plot(x.pca$x[,1], x.pca$x[,4], xlab = paste('PC1 (',x.pca.sum$importance[2,1], ')', sep = ''),ylab = paste('PC4 (',x.pca.sum$importance[2,4], ')', sep = ''), main = "PC1/4 all data", col ="black", pch = 20)
dev.off()

##### Covariate analysis ###########
covars = list(batch, type,sex,indiv,pluri,novel,der)
batch = samplenames$Batch
type = samplenames$Type
sex =  samplenames$Sex
age = samplenames$Age
pluri =  samplenames$Pluri
novel = samplenames$Novelty
matbot = samplenames$Matrigel.Bottle
pas = samplenames$Passage

covars = list(batch.f,sex.f,age.num,pluri.num ,novel.num,matbot.f,pas.f)

#Converted categorical covariates to a factor so they are levels 
batch.f = as.factor(batch)
pas.f = as.factor(pas)
matbot.f = as.factor(matbot)
sex.f = as.factor(sex)

##To look for correlations between covariates get the R^2 of the Pearson correlation
cor(novel, pluri)

#Converted numerical covariates to a numeric so they are continuous
pluri.num =as.numeric(pluri)
novel.num = as.numeric(novel)
age.num = as.numeric(age)


#Loop to create data table
lmPCA = function(pca, covars, npcs)
{
  results<-c()
  for (f in covars) {
    for (i in 1:npcs)
    {
      s = summary(lm(pca$x[,i]~f));
      results<-c(results,pf(s$fstatistic[[1]],
                            s$fstatistic[[2]],s$fstatistic[[3]], lower.tail = FALSE),
                 s$adj.r.squared)
    }
  }
  resultsM<-matrix(nrow = length(covars), ncol = 2*npcs, data =
                     results, byrow = TRUE)
  resultsM
  
  
}

pcaresults = lmPCA(x.pca,covars,4)
rownames(pcaresults) = c("batch", "sex","age","pluri","novel","matrigel bottle", "passage")
colnames(pcaresults) = c("PC1 pval", "PC1 adj R sqs","PC2 pval", "PC2 adj R sqs","PC3 pval", "PC3 adj R sqs","PC4 pval", "PC4 adj R sqs")

pcaresults.ipsc = lmPCA(ipsc.pca,covars.ipsc,4)
rownames(pcaresults.ipsc) = c("mef","batch","sex","indiv","pluri","novel","der")
colnames(pcaresults.ipsc) = c("PC1 pval", "PC1 adj R sqs","PC2 pval", "PC2 adj R sqs","PC3 pval", "PC3 adj R sqs","PC4 pval", "PC4 adj R sqs")


################## Varience explained ############
samplenames = read.table('covar.txt', header=T, sep ='\t')
#Re-order samplenames based on array location
samplenames = samplenames[order(samplenames$Order),]

rem = grep ("LCL|Fib" , samplenames$Name)
samplenames.ipsc = samplenames[-rem,]
origin_type= as.factor(samplenames.ipsc$Deriv)
ind = as.factor(samplenames.ipsc$Indiv)
meth.final = expr_gene_nosex

var.resid.err = matrix(ncol = 1, nrow = dim(meth.final)[1])
var.origin = matrix(ncol = 1, nrow = dim(meth.final)[1])
var.ind = matrix(ncol = 1, nrow = dim(meth.final)[1])

for (i in 1:dim(meth.final)[1]){
  #for(i in 1:100){
    tmp <- lm(unlist(meth.final[,grep ("LCL|Fib" , colnames(meth.final), invert = T)][i,]) ~ ind + origin_type)
  var.ind[i] <- anova(tmp)[1,2]/sum(anova(tmp)[,2])
  var.origin[i] <- anova(tmp)[2,2]/sum(anova(tmp)[,2])
  var.resid.err[i] <- anova(tmp)[3,2]/sum(anova(tmp)[,2])
}
p.origin = matrix(ncol = 1, nrow = dim(meth.final)[1])
p.ind = matrix(ncol = 1, nrow = dim(meth.final)[1])

for (i in 1:dim(meth.final)[1]){
  #for(i in 1:100){
  tmp <- lm(unlist(meth.final[,grep ("LCL|Fib" , colnames(meth.final), invert = T)][i,]) ~ ind + origin_type)
  p.ind[i] <- anova(tmp)[1,5]
  p.origin[i] <- anova(tmp)[2,5]
  
}
hist(p.origin)
hist(p.ind)

var.in.or = cbind(var.ind, var.origin, var.resid.err)

##### Adjust data using adjusted R-squared formula
adj.R.sq <- function(x,n,p){
  1-( ((1-x)*(n-1))/(n-p-1)  )
}

var.ind.adj = apply(var.ind, 1, function(x) adj.R.sq(x,16,3))
var.origin.adj = apply(var.origin, 1, function(x) adj.R.sq(x,16,1))

variation.adj <- cbind(var.ind.adj, var.origin.adj)
variation.adj.df <- data.frame(var.ind.adj, var.origin.adj)
colnames(variation.adj.df) <- c("ind", "origin")

variation.adj.df.m <- reshape2::melt(variation.adj.df, id.vars = NULL)

####### Bounded
variation.df <- data.frame(var.ind, var.origin, var.ind.adj, var.origin.adj)
variation.df[variation.df[,1] < 0 , 1] <- 0 
variation.df[variation.df[,2] < 0 , 2] <- 0 
variation.df[variation.df[,3] < 0 , 3] <- 0 
variation.df[variation.df[,4] < 0 , 4] <- 0 
colnames(variation.df) = c("ind", "origin", "ind.adj", "origin.adj")

variation.df.m <- reshape2::melt(variation.df, id.vars = NULL)

variation.adj.df <- data.frame(var.ind.adj, var.origin.adj)

variation.adj.df[variation.adj.df[,1] < 0 , 1] <- 0 
variation.adj.df[variation.adj.df[,2] < 0 , 2] <- 0 

colnames(variation.adj.df) <- c("ind", "origin")
variation.adj.df.m <- reshape2::melt(variation.adj.df, id.vars = NULL)

library(ggplot2)
###Create violin plots for proportion of variance explained
pdf(file = "Proportion_of_variance_violin.pdf")
pdf(file = "Proportion_of_variance_violin_bounded.pdf")
ggplot(variation.adj.df.m, aes(x = variable, y = value) ) + geom_violin(aes(fill = as.factor(variable) ), scale = "width", trim = T ) + theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"))
ggplot(variation.df.m, aes(x = variable, y = value) ) + geom_violin(aes(fill = as.factor(variable) ), scale = "width", trim = T ) + theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"))
ggplot(variation.adj.df.m, aes(x = variable, y = value) ) + geom_violin(aes(fill = as.factor(variable) ), scale = "width", trim = F ) + geom_boxplot(col = aes(fill = as.factor(variable)), width=.05, outlier.colour = NA) + theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"))

dev.off()

###### Get a gene coord file ##########
gene_coords = matrix(NA, ncol=8, nrow=length(expr_quant.all))

for(i in 1:dim(expr_quant.all)[1]){
  selection = which(goodprobes[,4]==row.names(expr_quant.all)[i])
  gene_coords[i,]= as.matrix(goodprobes[selection,])
}

gene_map = matrix(NA, ncol=8, nrow=length(unique(gene_names)))
i=0
for(gene in unique(gene_names)){
  i = i+1
  
  currRows = which(gene_names == gene)
  if(length(currRows)>1){
    if(goodprobes[currRows[1],6]=="+"){
      keepRow = currRows[which.max(goodprobes[currRows,2])]
    }
    else{
      keepRow = currRows[which.min(goodprobes[currRows,2])]
    }
  }
  else{
    keepRow=currRows[1]
  }
  gene_map[i,] = gene_coords[keepRow,1:11]
  
} 
colnames(gene_map) = colnames(goodprobes)
chr.gene = gene_map[,c(8,1)]

write.table(gene_map, 'OriginGeneCoords.txt', quote=F, sep ='\t', row.names=F)
